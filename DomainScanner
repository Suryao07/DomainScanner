#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Domain Scanner
A multi-threaded scanner for subdomains, virtual hosts, and pages.
Creator: https://github.com/Suryao07/
"""

import os
import sys
import shutil
import requests
import re
import time
import threading
import concurrent.futures
import socket
import ctypes
from urllib.parse import urlparse

LETTER = {
    "A": [" ___ ",
          " / _ \\ ",
          "/ /_\\ \\",
          "|  _  |",
          "| | | |",
          "\\_| |_/" ],
    "D": 
["______ ",
          "|  _  \\",
          "| | | |",
          "| | | |",
          "| |/ / ",
          "|___/  "],
    "O": [" _____ ",
          "/  _  \\",
          "| | | |",
          "| | | |",
          "\\ \\_/ /",
          " \\___/ "],
    "M": ["__  __ ",
          "|  \\/  |",
          "| .  . |",
          "| |\\/| |",
          "| |  | |",
 
          "|_|  |_|"],
    "I": [" _____ ",
           "|_   _|",
           "  | |  ",
           "  | |  ",
           " _| |_ ",
           " \\___/ "]
         
           ,
    "N": [" _   _ ",
          "| \\ | |",
          "|  \\| |",
          "| . ` |",
          "| |\\  |",
          "\\_| \\_/"],
    "S": [" _____ ",
          "/  ___|",
          "\\ `--. ",
          " `--. \\",
          "/\\__/ /",
          "\\____/ "],
    "C": [" _____ ",
          "/  __ \\",
          "| /  \\/",
          "| | ",
          "| \\__/\\",
          " \\____/"],
    "E": [" _____ ",
           "| ___|",
           "| |__  ",
           "|  __| ",
           "| |___ ",
           "\\____/"]
                    ,
    "R": ["______ ",
          "| ___ \\",
          "| |_/ /",
          "|  / /",
          "| |\\ \\ ",
          "\\_| \\_|"],
    " ": ["  ", "  ", "  ", "  ", "  ", "  "]
}

# --- Colors ---
RED_BOLD = "\033[1;31m"
GREEN_BOLD = "\033[1;32m"
CYAN_BOLD = "\033[1;36m"
YELLOW_BOLD = "\033[1;33m" 
RESET = "\033[0m"

# --- Globals ---
CREATOR_INFO = "             Tool Created By: https://github.com/Suryao07/"
MAX_THREADS = 100
print_lock = threading.Lock() 
progress_counter = 0 
SCRIPT_DIR = os.path.dirname(os.path.realpath(__file__))
DEFAULT_WORDLIST_DIR = os.path.join(SCRIPT_DIR, "wordlists")
DEFAULT_SUBDOMAIN_WORDLIST = "pro.txt" 
DEFAULT_PAGE_WORDLIST = "common_pages.txt"

def enable_windows_ansi():
    if os.name != "nt":
        return
    try:
        kernel32 = ctypes.windll.kernel32
        handle = kernel32.GetStdHandle(-11)
        mode = ctypes.c_uint()
        if kernel32.GetConsoleMode(handle, ctypes.byref(mode)):
            ENABLE_VIRTUAL_TERMINAL_PROCESSING = 0x0004
            kernel32.SetConsoleMode(handle, mode.value | ENABLE_VIRTUAL_TERMINAL_PROCESSING)
    except Exception:
        pass

def render_banner(text):
    text = text.upper()
    rows = len(next(iter(LETTER.values())))
    out_lines = []
    for r in range(rows):
        row_parts = []
        for ch in text:
            glyph = LETTER.get(ch, LETTER[" "])
            row_parts.append(glyph[r])
        out_lines.append("   ".join(row_parts))
    return "\n".join(out_lines)

def print_red_banner(text, center=True, padding=0):
    banner = render_banner(text)
    if center:
        try:
            term_width = shutil.get_terminal_size().columns
        except Exception:
            term_width = 80
        centered_lines = []
        for line in banner.splitlines():
            padded = (" " * padding) + line
            centered_lines.append(padded.center(term_width))
        banner = "\n".join(centered_lines)
    sys.stdout.write(RED_BOLD + banner + RESET + "\n")

# --- MODIFIED: Progress bar uses \r ---
def scan_dns(url, total_scans):
    """
    Scans a single URL via DNS. Reports any status except 404.
    """
    global progress_counter
    try:
        headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36'}
        response = requests.get(f"http://{url}", timeout=5, headers=headers, allow_redirects=False)
        
        if response.status_code != 404:
            with print_lock:
                # Print result on a new line, clearing progress bar
                sys.stdout.write(f"\r{GREEN_BOLD}[+] Found (DNS): {url} {YELLOW_BOLD}(Status: {response.status_code}){RESET}\n")
            return url 
        
        return None
         
    except (requests.exceptions.ConnectionError, requests.exceptions.RequestException):
        return None 
        
    finally:
        with print_lock:
            progress_counter += 1
            if progress_counter % 100 == 0 or progress_counter == total_scans:
                # Use \r to overwrite the current line and flush
                padding = " " * 10 
                sys.stdout.write(f"\r{YELLOW_BOLD}[*] Progress: {progress_counter}/{total_scans} scans completed.{RESET}{padding}")
                sys.stdout.flush()

# --- MODIFIED: Progress bar uses \r ---
def scan_vhost(ip_address, url_to_test, total_scans):
    """
    Scans a single IP for a virtual host. Reports any status except 404.
    """
    global progress_counter
    try:
        custom_headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36',
            'Host': url_to_test
        }
        
        response = requests.get(f"http://{ip_address}", timeout=5, headers=custom_headers, allow_redirects=False)
        
        if response.status_code != 404:
            with print_lock:
                # Print result on a new line, clearing progress bar
                sys.stdout.write(f"\r{GREEN_BOLD}[+] Found (VHost): {url_to_test} {YELLOW_BOLD}(Status: {response.status_code}){RESET}\n")
            return url_to_test
        
        return None
         
    except (requests.exceptions.ConnectionError, requests.exceptions.RequestException):
        return None 
        
    finally:
        with print_lock:
            progress_counter += 1
            if progress_counter % 100 == 0 or progress_counter == total_scans:
                # Use \r to overwrite the current line and flush
                padding = " " * 10 
                sys.stdout.write(f"\r{YELLOW_BOLD}[*] Progress: {progress_counter}/{total_scans} scans completed.{RESET}{padding}")
                sys.stdout.flush()

# --- MODIFIED: Progress bar uses \r ---
def scan_page(base_url, page_word, total_scans):
    """
    Scans for a page or directory on a base URL. Reports any status except 404.
    """
    global progress_counter
    target_url = f"{base_url}/{page_word}"
    try:
        headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36'}
        response = requests.get(target_url, timeout=5, headers=headers, allow_redirects=False)

        if response.status_code != 404:
            with print_lock:
                # Print result on a new line, clearing progress bar
                sys.stdout.write(f"\r{GREEN_BOLD}[+] Found Page: {target_url} {YELLOW_BOLD}(Status: {response.status_code}){RESET}\n")
            return target_url
        
        return None

    except (requests.exceptions.ConnectionError, requests.exceptions.RequestException):
        return None 
        
    finally:
        with print_lock:
            progress_counter += 1
            if progress_counter % 100 == 0 or progress_counter == total_scans:
                # Use \r to overwrite the current line and flush
                padding = " " * 10 
                sys.stdout.write(f"\r{YELLOW_BOLD}[*] Progress: {progress_counter}/{total_scans} scans completed.{RESET}{padding}")
                sys.stdout.flush()

def clean_and_validate_target(raw_target):
    """
    Cleans and validates user input.
    Returns (input_type, value, error_msg)
    """
    IP_REGEX = re.compile(r"^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
   
    if not raw_target:
        return None, None, "Input cannot be empty."
    
    target = raw_target.strip()

    if IP_REGEX.match(target):
        return 'ip', target, None

    if not target.startswith(('http://', 'https://')):
        target = 'http://' + target
    try:
        parsed_url = urlparse(target)
        domain = parsed_url.netloc
        domain = domain.split(':', 1)[0]
        
        if not domain:
             return None, None, "Invalid format. Could not extract domain."
        
        if IP_REGEX.match(domain):
            return 'ip', domain, None
        
        if '.' not in domain:
            return None, None, "Invalid domain format. Must contain a '.'"
            
        return 'domain', domain, None

    except Exception as e:
        return None, None, f"An error occurred during parsing: {e}"

# --- MODIFIED: Added a newline after loop ---
def run_scan(scan_mode, target_ip, base_domain, wordlist_path, total_scans):
    """
    Manages the thread pool and collects results.
    """
    global progress_counter
    progress_counter = 0 
    found_items = []
    start_time = time.time() 

    if scan_mode == 'vhost':
        sys.stdout.write(CYAN_BOLD + f"\n[*] Starting VHost scan on: {target_ip} (for {base_domain})\n" + RESET)
        scan_function = scan_vhost
    elif scan_mode == 'page':
        base_url = f"http://{base_domain}" 
        sys.stdout.write(CYAN_BOLD + f"\n[*] Starting Page scan on: {base_url}\n" + RESET)
        scan_function = scan_page
    else: # default to 'dns'
        sys.stdout.write(CYAN_BOLD + f"\n[*] Starting DNS scan on: {base_domain}\n" + RESET)
        scan_function = scan_dns
        
    sys.stdout.write(CYAN_BOLD + f"[*] Using wordlist: {wordlist_path} ({total_scans} words) with {MAX_THREADS} threads\n" + RESET)
    sys.stdout.write(CYAN_BOLD + ("-" * 30) + "\n" + RESET)

    try:
        with open(wordlist_path, 'r') as file:
            wordlist = [line.strip() for line in file if line.strip()]
    except Exception as e:
        sys.stdout.write(RED_BOLD + f"[-] Error reading wordlist during scan: {e}\n" + RESET)
        return

    with concurrent.futures.ThreadPoolExecutor(max_workers=MAX_THREADS) as executor:
        if scan_mode == 'vhost':
            futures = {executor.submit(scan_function, target_ip, f"{sub}.{base_domain}", total_scans): sub for sub in wordlist}
        elif scan_mode == 'page':
            futures = {executor.submit(scan_function, base_url, sub, total_scans): sub for sub in wordlist}
        else: # dns
            futures = {executor.submit(scan_function, f"{sub}.{base_domain}", total_scans): sub for sub in wordlist}
        
        try:
             for future in concurrent.futures.as_completed(futures):
                result = future.result()
                if result:
                    found_items.append(result)
                    
        except KeyboardInterrupt:
            sys.stdout.write(f"\n{RED_BOLD}[!] Scan interrupted by user. Stopping threads...{RESET}\n")
            executor.shutdown(wait=False, cancel_futures=True) 
    
    # --- ADDED THIS LINE ---
    # This moves the cursor to a new line after the progress bar is done
    sys.stdout.write("\n") 
    
    end_time = time.time()
    
    sys.stdout.write(CYAN_BOLD + ("-" * 30) + "\n" + RESET)
    sys.stdout.write(f"{CYAN_BOLD}[*] Scan complete in {end_time - start_time:.2f} seconds.{RESET}\n")
    if found_items:
        if scan_mode == 'page':
            sys.stdout.write(CYAN_BOLD + f"\n[+] Found {len(found_items)} responsive pages/directories (non-404):\n" + RESET)
        else:
            sys.stdout.write(CYAN_BOLD + f"\n[+] Found {len(found_items)} responsive subdomains (non-404):\n" + RESET)
        for item in found_items:
            sys.stdout.write(CYAN_BOLD + f"  - {item}\n" + RESET)
    else:
        if scan_mode == 'page':
            sys.stdout.write(CYAN_BOLD + "[-] No responsive (non-404) pages or directories found.\n" + RESET)
        else:
            sys.stdout.write(CYAN_BOLD + "[-] No responsive (non-404) subdomains found.\n" + RESET)
    return

def main_tool_loop():
    print_red_banner("DOMAIN SCANNER", center=True, padding=0)
    enable_windows_ansi()
    info_text = "\nThis tool scans for subdomains, VHosts, and pages.\n"
    sys.stdout.write(CYAN_BOLD + info_text + RESET)
    sys.stdout.write(CYAN_BOLD + CREATOR_INFO + RESET + "\n")
    warning = (
        "\nWarning: This tool is for educational purposes only.\n"
        "Unauthorized scanning of domains may be illegal and unethical.\n"
        "Always obtain permission before scanning any domain.\n"
        f"\n{YELLOW_BOLD}Type 'exit' or press CTRL+C to quit.{RESET}\n"
    )
    sys.stdout.write(RED_BOLD + warning + RESET)

    while True:
        sys.stdout.write("\n" + ("-" * 40) + "\n")
        domain_to_scan = None
        ip_to_scan = None
        scan_mode = 'dns'
        
        try:
            raw_domain_input = input(f"{YELLOW_BOLD}[+] Enter domain or IP (e.g., example.com): {RESET}")
            if raw_domain_input.lower() == 'exit':
                break
            
            input_type, value, error_msg = clean_and_validate_target(raw_domain_input)
            
            if error_msg:
                sys.stdout.write(f"{RED_BOLD}[-] Error: {error_msg}{RESET}\n")
                continue

            if input_type == 'ip':
                # Handle IP Input
                try:
                    hostname, _, _ = socket.gethostbyaddr(value)
                    sys.stdout.write(f"{GREEN_BOLD}[*] IP {value} resolves to hostname: {hostname}{RESET}\n")
                except (socket.herror, socket.gaierror):
                    sys.stdout.write(f"{RED_BOLD}[-] IP {value} does not resolve to a hostname.{RESET}\n")
                
                scan_choice = input(f"{YELLOW_BOLD}[?] Do you want to scan this IP for pages? (y/n): {RESET}").lower()
                if scan_choice.startswith('y'):
                    scan_mode = 'page'
                    domain_to_scan = value
                    ip_to_scan = None
                else:
                    sys.stdout.write(f"{CYAN_BOLD}[*] No scan will be performed.{RESET}\n")
                    continue
            
            elif input_type == 'domain':
                # Handle Domain Input (Forward Lookup)
                domain_to_scan = value
                try:
                    ip_address = socket.gethostbyname(value)
                    sys.stdout.write(f"{GREEN_BOLD}[*] Domain {value} resolves to IP: {ip_address}{RESET}\n")
                    
                    scan_choice = input(f"{YELLOW_BOLD}[?] Scan: (d)ns, (v)host, or (p)age? (default: d): {RESET}").lower()
                    if scan_choice.startswith('v'):
                        scan_mode = 'vhost'
                        ip_to_scan = ip_address
                    elif scan_choice.startswith('p'):
                        scan_mode = 'page'
                        ip_to_scan = None
                    else:
                        scan_mode = 'dns'
                        ip_to_scan = None
                        
                except socket.gaierror:
                    sys.stdout.write(f"{RED_BOLD}[-] Error: Could not resolve domain {value} to an IP. VHost scan not possible.{RESET}\n")
                    scan_choice = input(f"{YELLOW_BOLD}[?] Scan: (d)ns or (p)age? (default: d): {RESET}").lower()
                    if scan_choice.startswith('p'):
                        scan_mode = 'page'
                    else:
                        scan_mode = 'dns'
                    ip_to_scan = None

            if domain_to_scan:
                if scan_mode == 'page':
                    default_list_name = DEFAULT_PAGE_WORDLIST
                    sys.stdout.write(f"{YELLOW_BOLD}[!] Note: Page scanning selected. Using page/directory wordlist.{RESET}\n")
                else:
                    default_list_name = DEFAULT_SUBDOMAIN_WORDLIST
                    sys.stdout.write(f"{YELLOW_BOLD}[!] Note: Subdomain scanning selected. Using subdomain wordlist.{RESET}\n")
                
                wordlist_input = input(f"{YELLOW_BOLD}[+] Enter path or default wordlist name (default: {default_list_name}): {RESET}") or default_list_name
                
                if wordlist_input.lower() == 'exit':
                    break

                wordlist_path = None
                
                if os.path.isfile(wordlist_input):
                    wordlist_path = wordlist_input
                else:
                    potential_path = os.path.join(DEFAULT_WORDLIST_DIR, wordlist_input)
                    if os.path.isfile(potential_path):
                        wordlist_path = potential_path

                if not wordlist_path:
                    sys.stdout.write(RED_BOLD + f"[-] Error: Wordlist not found at '{wordlist_input}' or '{potential_path}'\n" + RESET)
                    continue
                
                try:
                    with open(wordlist_path, 'r') as f:
                        total_scans = sum(1 for line in f if line.strip())
                    if total_scans == 0:
                        sys.stdout.write(RED_BOLD + f"[-] Error: Wordlist '{wordlist_path}' is empty.\n" + RESET)
                        continue
                except Exception as e:
                    sys.stdout.write(RED_BOLD + f"[-] Error reading wordlist: {e}\n" + RESET)
                    continue
                
                run_scan(scan_mode, ip_to_scan, domain_to_scan, wordlist_path, total_scans) 
                     
        except EOFError:
             break
        except KeyboardInterrupt:
             break

if __name__ == "__main__":
    try:
        main_tool_loop()
        sys.stdout.write(f"\n{CYAN_BOLD}Exiting scanner. Goodbye!{RESET}\n")
    except KeyboardInterrupt:
        sys.stdout.write(f"\n{RED_BOLD}[!] Exiting scanner. Goodbye!{RESET}\n")
        sys.exit(0)
    except Exception as e:
        sys.stdout.write(f"\n{RED_BOLD}[!] An unexpected error occurred: {e}{RESET}\n")
